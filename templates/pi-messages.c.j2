{#
/*
 * Copyright 2023, 2024 Till Blaha (Delft University of Technology)
 *
 * This program is free software: you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free
 * Software Foundation, either version 3 of the License, or (at your option) any
 * later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License along
 * with this program.
 *
 * If not, see <https://www.gnu.org/licenses/>.
 */
#}
{{ license }}

/* THIS FILE HAS BEEN AUTOGENERATED BY generate.py, DO NOT MODIFY */

#include <stdint.h>
#include "pi-messages.h"
#include "pi-protocol.h"
#include <stdio.h>

{% for msg in msgs %}
{% set piMsg = "piMsg"+msg.nameCamelCase %}
{% set piMsgDefine = "PI_MSG_"+msg.nameSNAKE_CAPS %}
{% set piMsgTypedef = "pi_"+msg.nameSNAKE_CAPS+"_t" %}
// ---- {{msg.nameSNAKE_CAPS}} ---- //
#if (PI_MODE & PI_TX) && ({{piMsgDefine}}_MODE & PI_TX)
{{piMsgTypedef}} {{piMsg}}Tx = {.id={{piMsgDefine}}_ID, .len={{piMsgDefine}}_PAYLOAD_LEN};
#endif

#if (PI_MODE & PI_RX) && ({{piMsgDefine}}_MODE & PI_RX)
{{piMsgTypedef}} {{piMsg}}A = {.id={{piMsgDefine}}_ID, .len={{piMsgDefine}}_PAYLOAD_LEN};
{{piMsgTypedef}} {{piMsg}}B = {.id={{piMsgDefine}}_ID, .len={{piMsgDefine}}_PAYLOAD_LEN};
{{piMsgTypedef}}* {{piMsg}}Rx = NULL;
pi_msg_rx_state_t {{piMsg}}RxState = PI_MSG_RX_STATE_NONE;
#endif


{% endfor %}


// ---- parsing function ---- //
#if (PI_MODE & PI_RX)
pi_parse_msg_result_t piParseIntoMsg(pi_parse_states_t * p, const uint8_t byte) {
    //p->curMsgId = 0;
    //p->piMsgRxBuffer = NULL;
    //p->piMsgRx_ptr = NULL;
    //p->piMsgA_ptr = NULL;
    //p->piMsgB_ptr = NULL;
    //p->piMsgRxState_ptr = NULL;
    //p->piMsgLen = 0;

    pi_parse_msg_result_t res = PI_PARSE_MSG_NO_ERROR;

    if (p->msgId > PI_MSG_MAX_ID)
        return PI_PARSE_MSG_INVALID_ID;

    //if (byteCount > PI_MSG_MAX_PAYLOAD_LEN)
    //    return PI_PARSE_MSG_EXCEEDS_MAX_PAYLOAD_LEN;

    if ((p->curMsgId != p->msgId) || (p->byteCount == 0)) {
        // reset and re-assign buffers
        p->curMsgId = p->msgId;

        switch(p->msgId) {
{% for msg in msgs %}
{% set piMsg = "piMsg"+msg.nameCamelCase %}
{% set piMsgDefine = "PI_MSG_"+msg.nameSNAKE_CAPS %}
{% set piMsgTypedef = "pi_"+msg.nameSNAKE_CAPS+"_t" %}
#if ({{piMsgDefine}}_MODE & PI_RX)
            case {{piMsgDefine}}_ID:
                p->piMsgRx_ptr = (void *)&{{piMsg}}Rx;
                p->piMsgA_ptr = &{{piMsg}}A;
                p->piMsgB_ptr = &{{piMsg}}B;
                p->piMsgRxState_ptr = &{{piMsg}}RxState;
                p->piMsgLen = {{piMsgDefine}}_PAYLOAD_LEN;
                break;
#endif
{% endfor %}
            default:
                return PI_PARSE_MSG_NO_SUCH_MSG;
        }
    }

    if (p->byteCount == 0) {
        p->piMsgRxBuffer = (*(p->piMsgRxState_ptr) > PI_MSG_RX_STATE_A) ? p->piMsgA_ptr : p->piMsgB_ptr;
    } else if (p->byteCount > p->piMsgLen) {
        return PI_PARSE_MSG_EXCEEDS_MSG_PAYLOAD_LEN;
    } else if (p->byteCount == p->piMsgLen) {
        // check checksum. Either it's invalid, or we have a successful message
        if (p->checksum == byte) {
            // success! let's set the rx pointer accordingly
            *(p->piMsgRxState_ptr) = (*(p->piMsgRxState_ptr) == PI_MSG_RX_STATE_A) ? PI_MSG_RX_STATE_B : PI_MSG_RX_STATE_A;
            *(p->piMsgRx_ptr) = (*(p->piMsgRxState_ptr) == PI_MSG_RX_STATE_A) ? p->piMsgA_ptr : p->piMsgB_ptr;
            return PI_PARSE_MSG_SUCCESS;
        } else {
            return PI_PARSE_MSG_INVALID_CHECKSUM;
        }
    }

    if (p->piMsgRxBuffer) {
        *((uint8_t *)p->piMsgRxBuffer + p->byteCount + PI_MSG_PAYLOAD_LEN_BYTES + PI_MSG_ID_BYTES) = byte;
        p->checksum = crc8_calc(p->checksum, byte, PI_CRC8_POLYNOMIAL);
    } else {
        return PI_PARSE_MSG_NULL_BUFFER;
    }

    return res;
}
#endif  // PI_MODE & PI_RX


// printing function
#if (PI_MODE & PI_RX) && defined(PI_USE_PRINT_MSGS)
void piPrintMsgs(int (*printer)(const char* s, ...)) {
    static int i = 0;
    printer("\n+------------ piPrintMsgs invokation %d -------------+\n", i++);
{% for msg in msgs %}
{% set piMsgDefine = "PI_MSG_"+msg.nameSNAKE_CAPS %}
#if {{piMsgDefine}}_MODE & PI_RX
    piPrintMsg{{msg.nameCamelCase}}(printer);
#endif
{% endfor %}
}
#endif
